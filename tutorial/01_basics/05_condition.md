# 条件分支语句

Rust 是一种系统级编程语言，强调安全性和性能。在 Rust 中，条件分支语句用于根据条件执行不同的代码路径。主要包括 `if`、`else if`、`else` 语句，以及更强大的 `match` 表达式。本教程将从基础开始逐步讲解这些语句的使用方式，包括语法、示例和注意事项。假设你已经安装了 Rust 环境（可以通过 `rustup` 安装），并使用 `cargo` 创建一个新项目来测试代码。

所有示例代码都可以复制到 `src/main.rs` 文件中运行，使用 `cargo run` 执行。

## 1. 基础：`if` 语句

`if` 语句是 Rust 中最简单的条件分支形式。它检查一个布尔表达式（必须返回 `bool` 类型），如果为真，则执行代码块。

### 语法
```rust
if 条件 {
    // 代码块
}
```

### 示例
```rust
fn main() {
    let number = 5;

    if number > 0 {
        println!("数字是正数");
    }

    println!("程序继续执行");  // 这行总是执行
}
```

### 输出
```
数字是正数
程序继续执行
```

### 注意事项
- 条件必须是 `bool` 类型，不能像一些语言那样隐式转换为布尔（例如，不能直接用整数作为条件）。
- 不需要括号包围条件，但代码块必须用大括号 `{}` 包围。
- 如果条件为假，代码块将被跳过。

## 2. `if-else` 语句

添加 `else` 可以处理条件为假的情况。

### 语法
```rust
if 条件 {
    // 真时执行
} else {
    // 假时执行
}
```

### 示例
```rust
fn main() {
    let number = -3;

    if number > 0 {
        println!("数字是正数");
    } else {
        println!("数字是非正数");
    }
}
```

### 输出
```
数字是非正数
```

### 注意事项
- `else` 块是可选的。
- 两个分支的代码块必须用 `{}` 包围，即使只有一行代码。

## 3. `if-else if-else` 链

对于多个条件，可以链式使用 `else if`。

### 语法
```rust
if 条件1 {
    // 条件1 为真
} else if 条件2 {
    // 条件1 为假，条件2 为真
} else {
    // 所有条件为假
}
```

### 示例
```rust
fn main() {
    let score = 85;

    if score >= 90 {
        println!("优秀");
    } else if score >= 80 {
        println!("良好");
    } else if score >= 60 {
        println!("及格");
    } else {
        println!("不及格");
    }
}
```

### 输出
```
良好
```

### 注意事项
- 条件按顺序检查，一旦一个为真，后续分支将被跳过。
- 可以有任意多个 `else if`，但只有一个 `else`。
- 避免过多链式 `else if`，因为这可能导致代码复杂；考虑使用 `match` 代替。

## 4. 在赋值中使用 `if`（作为表达式）

Rust 的 `if` 是一个表达式，可以返回一个值，因此可以用于变量赋值。这类似于其他语言的三元运算符，但更灵活。

### 语法
```rust
let 变量 = if 条件 {
    值1
} else {
    值2
};
```

### 示例
```rust
fn main() {
    let number = 7;

    let description = if number % 2 == 0 {
        "偶数"
    } else {
        "奇数"
    };

    println!("数字是：{}", description);
}
```

### 输出
```
数字是：奇数
```

### 注意事项
- 所有分支必须返回相同类型的值。
- 分支末尾不能有分号 `;`，因为这是表达式而非语句。
- 如果没有 `else`，编译会失败，因为表达式必须有值。

## 5. `match` 表达式：更强大的分支

`match` 是 Rust 中处理枚举和模式匹配的核心工具，常用于条件分支。它比 `if` 更安全，因为它要求穷尽所有可能情况（exhaustive matching）。

### 语法
```rust
match 值 {
    模式1 => 表达式1,
    模式2 => 表达式2,
    _ => 默认表达式,  // 通配符，处理剩余情况
}
```

### 示例：简单匹配
```rust
fn main() {
    let day = 3;

    let weekday = match day {
        1 => "星期一",
        2 => "星期二",
        3 => "星期三",
        4 => "星期四",
        5 => "星期五",
        _ => "周末",
    };

    println!("今天是：{}", weekday);
}
```

### 输出
```
今天是：星期三
```

### 示例：带条件的匹配（Guard）
```rust
fn main() {
    let number = 13;

    match number {
        x if x % 2 == 0 => println!("偶数"),
        x if x > 10 => println!("大于10的奇数"),
        _ => println!("其他"),
    }
}
```

### 输出
```
大于10的奇数
```

### 注意事项
- `match` 必须覆盖所有可能的值，否则编译错误（使用 `_` 通配符处理剩余）。
- 每个臂（arm）以逗号 `,` 结束。
- 支持模式匹配，如范围 `1..=5`、枚举、结构体解构等。
- `match` 是表达式，可以返回值。

## 6. 常见错误与最佳实践

使用表格总结常见问题：

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 条件不是 `bool` | Rust 不允许隐式转换 | 显式使用比较运算符，如 `x > 0` |
| 缺少 `{}` | 代码块必须用大括号 | 总是添加 `{}`，即使单行 |
| `match` 未穷尽 | 未覆盖所有模式 | 添加 `_ => ...` |
| 类型不匹配 | 分支返回不同类型 | 确保所有分支返回相同类型 |
| 性能问题 | 过多 `else if` | 使用 `match` 优化 |

- **最佳实践**：优先使用 `match` 处理枚举或有限值；用 `if` 处理简单布尔条件。保持代码简洁，避免嵌套过多。
- **调试**：使用 `cargo build` 检查编译错误，`cargo run` 测试运行。

## 7. 练习

1. 编写一个函数，输入一个整数，输出是否为质数（使用 `if`）。
2. 使用 `match` 实现一个简单计算器，支持加减乘除。
3. 处理用户输入：读取命令行参数，根据参数值分支执行不同操作（需引入 `std::env`）。

通过这些示例，你应该能掌握 Rust 的条件分支。更多细节可参考 Rust 官方文档（The Rust Book）。如果有疑问，欢迎提供具体代码反馈！